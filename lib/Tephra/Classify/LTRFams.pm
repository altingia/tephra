package Tephra::Classify::LTRFams;

use 5.010;
use Moose;
use MooseX::Types::Path::Class;
use Statistics::Descriptive;
use Sort::Naturally;
use List::MoreUtils qw(indexes any);
use File::Spec;
use File::Find;
use File::Basename;
use Bio::SeqIO;
use Bio::Tools::GFF;
use Number::Range;
use Time::HiRes qw(gettimeofday);
use File::Path  qw(make_path);
use Parallel::ForkManager;
use Cwd;
use Try::Tiny;
use Tephra::Config::Exe;
use namespace::autoclean;
#use Data::Dump::Color;

with 'Tephra::Role::GFF',
     'Tephra::Role::Util';

=head1 NAME

Tephra::Classify::LTRFams - Classify LTR retrotransposons into families

=head1 VERSION

Version 0.01

=cut

our $VERSION = '0.01';
$VERSION = eval $VERSION;

=head1 SYNOPSIS

    use Tephra::Classify::LTRFams;

    my $genome  = 'genome.fasta';     # genome sequences in FASTA format
    my $outdir  = 'ltr_families_out'; # directory to place the results
    my $threads = 12;                 # the number of threads to use for parallel processing
    my $gyp_gff = 'gypsy_ltrs.gff3';  # GFF file generated by Tephra::Classify::LTRSFams
    my $cop_gff = 'copia_ltrs.gff3';  # GFF file generated by Tephra::Classify::LTRSFams

    my $classify_fams_obj = Tephra::Classify::LTRFams->new(
        genome   => $genome,
        outdir   => $outdir,
        threads  => $threads,
    );

    my $gyp_dir = $classify_fams_obj->extract_features($gyp_gff);
    my $gyp_clusters = $classify_fams_obj->cluster_features($gyp_dir);
    my $gyp_fams = $classify_fams_obj->parse_clusters($gyp_clusters);
    
    my $cop_dir = $classify_fams_obj->extract_features($cop_gff);
    my $cop_clusters = $classify_fams_obj->cluster_features($cop_dir);
    my $cop_fams = $classify_fams_obj->parse_clusters($cop_clusters);

    my %outfiles;
    @outfiles{keys %$_} = values %$_ for ($gyp_fams, $cop_fams);
    $classify_fams_obj->combine_families(\%outfiles);

=cut

has genome => (
    is       => 'ro',
    isa      => 'Path::Class::File',
    required => 1,
    coerce   => 1,
);

has outdir => (
    is       => 'ro',
    isa      => 'Path::Class::Dir',
    required => 1,
    coerce   => 1,
);

has threads => (
    is        => 'ro',
    isa       => 'Int',
    predicate => 'has_threads',
    lazy      => 1,
    default   => 1,
);

#
# methods
#
sub extract_features {
    my $self = shift;
    my $fasta  = $self->genome;
    my $dir    = $self->outdir;
    my ($infile) = @_;
    
    my ($name, $path, $suffix) = fileparse($infile, qr/\.[^.]*/);
    my $type = ($name =~ /(?:gypsy|copia|unclassified)$/i);
    die "\nERROR: Unexpected input. Should match /gypsy|copia|unclassified$/i. Exiting."
	unless defined $type;

    my $resdir = File::Spec->catdir($dir, $name);
    unless ( -d $resdir ) {
	make_path( $resdir, {verbose => 0, mode => 0771,} );
    }
    
    my $comp = File::Spec->catfile($resdir, $name."_complete.fasta");
    my $ppts = File::Spec->catfile($resdir, $name."_ppt.fasta");
    my $pbs  = File::Spec->catfile($resdir, $name."_pbs.fasta");
    my $five_pr_ltrs  = File::Spec->catfile($resdir, $name."_5prime-ltrs.fasta");
    my $three_pr_ltrs = File::Spec->catfile($resdir, $name."_3prime-ltrs.fasta");

    open my $allfh, '>>', $comp or die "\nERROR: Could not open file: $comp\n";
    open my $pptfh, '>>', $ppts or die "\nERROR: Could not open file: $ppts\n";
    open my $pbsfh, '>>', $pbs or die "\nERROR: Could not open file: $pbs\n";
    open my $fivefh, '>>', $five_pr_ltrs or die "\nERROR: Could not open file: $five_pr_ltrs\n";
    open my $threfh, '>>', $three_pr_ltrs or die "\nERROR: Could not open file: $three_pr_ltrs\n";

    my $gffio = Bio::Tools::GFF->new( -file => $infile, -gff_version => 3 );

    my ($start, $end, $elem_id, $key, %feature, %ltrs, %seen);
    while (my $feature = $gffio->next_feature()) {
	if ($feature->primary_tag eq 'LTR_retrotransposon') {
	    my @string = split /\t/, $feature->gff_string;
	    ($elem_id) = ($string[8] =~ /ID=?\s+?(LTR_retrotransposon\d+)/);
	    ($start, $end) = ($feature->start, $feature->end);
	    $key = join ".", $elem_id, $start, $end;
	    $ltrs{$key}{'full'} = join "||", $string[0], $feature->primary_tag, @string[3..4];
	}
	next unless defined $start && defined $end;
	if ($feature->primary_tag eq 'long_terminal_repeat') {
	    my @string = split /\t/, $feature->gff_string;
	    if ($feature->start >= $start && $feature->end <= $end) {
		my $ltrkey = join "||", $string[0], $feature->primary_tag, @string[3,4,6];
		push @{$ltrs{$key}{'ltrs'}}, $ltrkey unless exists $seen{$ltrkey};
		$seen{$ltrkey} = 1;
	    }
	}
	elsif ($feature->primary_tag eq 'primer_binding_site') {
	    my @string = split /\t/, $feature->gff_string;
	    if ($feature->start >= $start && $feature->end <= $end) {
		my ($name) = ($string[8] =~ /trna \"?(\w+.*)\"?\s+\;/);
		$ltrs{$key}{'pbs'} =
		    join "||", $string[0], $feature->primary_tag, $name, @string[3..4];
	    }
	}
	elsif ($feature->primary_tag eq 'protein_match') {
	    my @string = split /\t/, $feature->gff_string;
	    if ($feature->start >= $start && $feature->end <= $end) {
		my ($name) = ($string[8] =~ /name \"?(\w+)\"?/);
		my $pdomkey = join "||", $string[0], $feature->primary_tag, $name, @string[3,4,6];
		push @{$ltrs{$key}{'pdoms'}{$name}}, $pdomkey unless exists $seen{$pdomkey};
		$seen{$pdomkey} = 1;
	    }
	}
	elsif ($feature->primary_tag eq 'RR_tract') {
	    my @string = split /\t/, $feature->gff_string;
	    if ($feature->start >= $start && $feature->end <= $end) {
		$ltrs{$key}{'ppt'} =
		    join "||", $string[0], $feature->primary_tag, @string[3..4];
	    }
	}
    }

    my %pdoms;
    my $ltrct = 0;
    for my $ltr (sort keys %ltrs) {
	my ($element, $rstart, $rend) = split /\./, $ltr;
	# full element
	my ($source, $prim_tag, $fstart, $fend) = split /\|\|/, $ltrs{$ltr}{'full'};
	my $full_tmp = File::Spec->catfile($resdir, $ltr.".fasta");
	$self->subseq($fasta, $source, $element, $fstart, $fend, $full_tmp, $allfh);

	# pbs
	if ($ltrs{$ltr}{'pbs'}) {
	    my ($pbssource, $pbstag, $trna, $pbsstart, $pbsend) = split /\|\|/, $ltrs{$ltr}{'pbs'};
	    my $pbs_tmp = File::Spec->catfile($resdir, $ltr."_pbs.fasta");
	    $self->subseq($fasta, $pbssource, $element, $pbsstart, $pbsend, $pbs_tmp, $pbsfh);
	}

	# ppt
	if ($ltrs{$ltr}{'ppt'}) {
	    my ($pptsource, $ppttag, $pptstart, $pptend) = split /\|\|/, $ltrs{$ltr}{'ppt'};
	    my $ppt_tmp = File::Spec->catfile($resdir, $ltr."_ppt.fasta");
	    $self->subseq($fasta, $source, $element, $pptstart, $pptend, $ppt_tmp, $pptfh);
	}

	for my $ltr_repeat (@{$ltrs{$ltr}{'ltrs'}}) {
	    my ($src, $ltrtag, $s, $e, $strand) = split /\|\|/, $ltr_repeat;
	    my $lfname = $ltr;
	    if ($ltrct) {
		$lfname .= "_5prime-ltr.fasta" if $strand eq '+';
		$lfname .= "_3prime-ltr.fasta" if $strand eq '-';
		my $fiveprime_tmp = File::Spec->catfile($resdir, $lfname);
		$self->subseq($fasta, $src, $element, $s, $e, $fiveprime_tmp, $fivefh);
		$ltrct = 0;
	    }
	    else {
		$lfname .= "_3prime-ltr.fasta" if $strand eq '+';
		$lfname .= "_5prime-ltr.fasta" if $strand eq '-';
		my $threeprime_tmp = File::Spec->catfile($resdir, $lfname);
		$self->subseq($fasta, $src, $element, $s, $e, $threeprime_tmp, $threfh);
		$ltrct++;
	    }
	}

	if ($ltrs{$ltr}{'pdoms'}) {
	    for my $model_name (keys %{$ltrs{$ltr}{'pdoms'}}) {
		for my $ltr_repeat (@{$ltrs{$ltr}{'pdoms'}{$model_name}}) {
		    my ($src, $pdomtag, $name, $s, $e, $str) = split /\|\|/, $ltr_repeat;
		    #"Ha10||protein_match||UBN2||132013916||132014240",
		    push @{$pdoms{$src}{$element}{$name}}, join "||", $s, $e, $str;
		}
	    }
	}
    }
    close $allfh;
    close $pptfh;
    close $pbsfh;
    close $fivefh;
    close $threfh;

    ## This is where we merge overlapping hits in a chain and concatenate non-overlapping hits
    ## to create a single domain sequence for each element
    #dd \%pdoms; # and exit;
    for my $src (keys %pdoms) {
	for my $element (keys %{$pdoms{$src}}) {
	    my ($pdom_s, $pdom_e, $str);
	    for my $pdom_type (keys %{$pdoms{$src}{$element}}) {
		my (%lrange, %seqs, $union);
		my $pdom_file = File::Spec->catfile($resdir, $pdom_type."_pdom.fasta");
		open my $fh, '>>', $pdom_file or die "\nERROR: Could not open file: $pdom_file\n";
		for my $split_dom (@{$pdoms{$src}{$element}{$pdom_type}}) {
		    ($pdom_s, $pdom_e, $str) = split /\|\|/, $split_dom;
		    push @{$lrange{$src}{$element}{$pdom_type}}, "$pdom_s..$pdom_e";
		}
		
		if (@{$lrange{$src}{$element}{$pdom_type}} > 1) {
		    #say STDERR "over 1: $element -> $pdom_type";
		    {
			no warnings; # Number::Range warns on EVERY single interger that overlaps
			my $range = Number::Range->new(@{$lrange{$src}{$element}{$pdom_type}});
			$union    = $range->range;
		    }
		    #dd $union;
		    
		    for my $r (split /\,/, $union) {
			my ($ustart, $uend) = split /\.\./, $r;
			my $tmp = File::Spec->catfile($resdir, $element."_".$pdom_type.".fasta");
			my $seq = $self->subseq_pdoms($fasta, $src, $element, $ustart, $uend, $tmp);
			my $k = join "-", $ustart, $uend;
			$seqs{$k} = $seq;
		    }
		    
		    #dd \%seqs;
		    $self->concat_pdoms($src, $element, \%seqs, $fh);
		}
		else {
		    my ($nustart, $nuend, $str) = split /\|\|/, @{$pdoms{$src}{$element}{$pdom_type}}[0];
		    my $tmp = File::Spec->catfile($resdir, $element."_".$pdom_type.".fasta");
		    $self->subseq($fasta, $src, $element, $nustart, $nuend, $tmp, $fh);
		}
		close $fh;
		%seqs   = ();
		%lrange = ();
		unlink $pdom_file if ! -s $pdom_file;
	    }
	}
    }

    for my $file ($comp, $ppts, $pbs, $five_pr_ltrs, $three_pr_ltrs) {
	unlink $file if ! -s $file;
    }

    return $resdir
}

sub subseq_pdoms {
    my $self = shift;
    my ($fasta, $loc, $elem, $start, $end, $tmp) = @_;

    my $config = Tephra::Config::Exe->new->get_config_paths;
    my ($samtools) = @{$config}{qw(samtools)};
    my $cmd = "$samtools faidx $fasta $loc:$start-$end > $tmp";
    $self->run_cmd($cmd);

    my $seq;
    if (-s $tmp) {
	my $seqio = Bio::SeqIO->new( -file => $tmp, -format => 'fasta' );
	while (my $seqobj = $seqio->next_seq) {
	    $seq = $seqobj->seq;
	}
    }
    unlink $tmp;
    return $seq;
}

sub concat_pdoms {
    my $self = shift;
    my ($src, $elem, $seqs, $fh_out) = @_;
    my $ranges = join "_", keys %$seqs;
    my $id = $src."_".$elem."_$ranges";

    my $concat_seq;
    for my $seq (values %$seqs) {
	$concat_seq .= $seq;
    }
    $concat_seq =~ s/.{60}\K/\n/g;
    say $fh_out join "\n", ">$id", $concat_seq;
}

sub collect_feature_args {
    my $self = shift;
    my ($dir) = @_;
    my (@fiveltrs, @threeltrs, @ppt, @pbs, @pdoms, %vmatch_args);
    find( sub { push @fiveltrs, $File::Find::name if -f and /5prime-ltrs.fasta$/ }, $dir);
    find( sub { push @threeltrs, $File::Find::name if -f and /3prime-ltrs.fasta$/ }, $dir);
    find( sub { push @ppt, $File::Find::name if -f and /ppts.fasta$/ }, $dir);
    find( sub { push @pbs, $File::Find::name if -f and /pbs.fasta$/ }, $dir);
    find( sub { push @pdoms, $File::Find::name if -f and /pdom.fasta$/ }, $dir);

    # ltr
    my $ltr5name = File::Spec->catfile($dir, 'dbcluster-5primeseqs');
    my $fiveargs = "-dbcluster 80 20 $ltr5name -p -d -seedlength 10 ";
    $fiveargs .= "-exdrop 7 -l 80 -showdesc 0 -sort ld -best 100 -identity 80";
    $vmatch_args{fiveltr} = { seqs => \@fiveltrs, args => $fiveargs };

    my $ltr3name  = File::Spec->catfile($dir, 'dbcluster-3primeseqs');
    my $threeargs = "-dbcluster 80 20 $ltr3name -p -d -seedlength 10 ";
    $threeargs .= "-exdrop 7 -l 80 -showdesc 0 -sort ld -best 100 -identity 80";
    $vmatch_args{threeltr} = { seqs => \@threeltrs, args => $threeargs };

    # pbs/ppt
    my $pbsname = File::Spec->catfile($dir, 'dbcluster-pbs');
    my $pbsargs = "-dbcluster 90 90 $pbsname -p -d -seedlength 5 -exdrop 2 ";
    $pbsargs .= "-l 3 -showdesc 0 -sort ld -best 100";
    $vmatch_args{pbs} = { seqs => \@pbs, args => $pbsargs, prefixlen => 1 };

    my $pptname = File::Spec->catfile($dir, 'dbcluster-ppt');
    my $pptargs = "-dbcluster 90 90 $pptname -p -d -seedlength 5 -exdrop 2 ";
    $pptargs .= "-l 3 -showdesc 0 -sort ld -best 100";
    $vmatch_args{ppt} = { seqs => \@ppt, args => $pptargs, prefixlen => 5 };

    # pdoms
    my $pdomname = File::Spec->catfile($dir, 'dbcluster-pdoms');
    my $pdomargs = "-dbcluster 80 80 $pdomname -p -d -seedlength 10 -exdrop 3 ";
    $pdomargs .= "-l 40 -showdesc 0 -sort ld -best 100";
    $vmatch_args{pdoms} = { seqs => \@pdoms, args => $pdomargs };

    return \%vmatch_args;
}

sub cluster_features {
    my $self = shift;
    my $threads = $self->threads;
    my ($dir) = @_;

    my $args = $self->collect_feature_args($dir);
    $self->_remove_singletons($args);

    my $t0 = gettimeofday();
    my $doms = 0;
    my %reports;
    my $outfile = File::Spec->catfile($dir, 'all_vmatch_reports.txt');
    my $logfile = File::Spec->catfile($dir, 'all_vmatch_reports.log');
    open my $out, '>>', $outfile or die "\nERROR: Could not open file: $outfile\n";
    open my $log, '>>', $logfile or die "\nERROR: Could not open file: $logfile\n";
    
    my $pm = Parallel::ForkManager->new($threads);
    $pm->run_on_finish( sub { my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_ref) = @_;
			      for my $bl (sort keys %$data_ref) {
				  open my $report, '<', $bl or die "\nERROR: Could not open file: $bl\n";
				  print $out $_ while <$report>;
				  close $report;
				  unlink $bl;
			      }
			      my $t1 = gettimeofday();
			      my $elapsed = $t1 - $t0;
			      my $time = sprintf("%.2f",$elapsed/60);
			      say $log basename($ident),
			      " just finished with PID $pid and exit code: $exit_code in $time minutes";
			} );

    for my $type (keys %$args) {
	for my $db (@{$args->{$type}{seqs}}) {
	    $doms++;
	    $pm->start($db) and next;
	    my $vmrep = $self->process_cluster_args($args, $type, $db);
	    $reports{$vmrep} = 1;

	    $pm->finish(0, \%reports);
	}
    }

    $pm->wait_all_children;
    close $out;

    my $t2 = gettimeofday();
    my $total_elapsed = $t2 - $t0;
    my $final_time = sprintf("%.2f",$total_elapsed/60);

    say $log "\n========> Finished running vmatch on $doms domains in $final_time minutes";
    close $log;

    return $outfile;
}

sub process_cluster_args {
    my $self = shift;
    my ($args, $type, $db) = @_;

    my ($name, $path, $suffix) = fileparse($db, qr/\.[^.]*/);
    my $index = File::Spec->catfile($path, $name.".index");
    my $vmrep = File::Spec->catfile($path, $name."_vmatch-out.txt");
    my $log   = File::Spec->catfile($path, $name."_vmatch-out.log");;

    my $mkvtreecmd = "mkvtree -db $db -dna -indexname $index -allout -v -pl ";
    if (defined $args->{$type}{prefixlen}) {
	$mkvtreecmd .= "$args->{$type}{prefixlen} ";
    }
    $mkvtreecmd .= "2>&1 > $log";
    my $vmatchcmd  = "vmatch $args->{$type}{args} $index > $vmrep";
    $self->run_cmd($mkvtreecmd);
    $self->run_cmd($vmatchcmd);
    unlink glob "$index*";
    unlink glob "$path/*.match";

    return $vmrep;
}

sub subseq {
    my $self = shift;
    my ($fasta, $loc, $elem, $start, $end, $tmp, $out) = @_;
    #my $samtools = File::Spec->catfile($ENV{HOME}, '.tephra', 'samtools-1.2', 'samtools');
    my $config = Tephra::Config::Exe->new->get_config_paths;
    my ($samtools) = @{$config}{qw(samtools)};
    my $cmd = "$samtools faidx $fasta $loc:$start-$end > $tmp";
    $self->run_cmd($cmd);

    my $id = join "_", $loc, $elem, "$start-$end";
    if (-s $tmp) {
	my $seqio = Bio::SeqIO->new( -file => $tmp, -format => 'fasta' );
	while (my $seqobj = $seqio->next_seq) {
	    my $seq = $seqobj->seq;
	    if ($seq) {
		$seq =~ s/.{60}\K/\n/g;
		say $out join "\n", ">$id", $seq;
	    }
	}
    }
    unlink $tmp;
}

sub parse_clusters {
    my $self = shift;
    my ($clsfile) = @_;
    my $genome = $self->genome;
    
    my ($name, $path, $suffix) = fileparse($genome, qr/\.[^.]*/);
    if ($name =~ /(\.fa.*)/) {
	$name =~ s/$1//;
    }

    my ($cname, $cpath, $csuffix) = fileparse($clsfile, qr/\.[^.]*/);
    my $dir = basename($cpath);
    my ($sf)  = ($dir =~ /_(\w+)$/);
    my $sfname;
    $sfname = 'RLG' if $sf =~ /gypsy/i;
    $sfname = 'RLC' if $sf =~ /copia/i;
    $sfname = 'RLX' if $sf =~ /unclassified/i;

    my @compfiles;
    find( sub { push @compfiles, $File::Find::name if /complete.fasta$/ }, $cpath );
    my $ltrfas = shift @compfiles;
    my $seqstore = $self->_store_seq($ltrfas);
    #say "DEBUG: ltrfas -> $ltrfas";
    #say "DEBUG: clsfile -> $clsfile";
    #dd $seqstore;
    
    my (%cls, %all_seqs, %all_pdoms, $clusnum, $dom);
    open my $in, '<', $clsfile;

    while (my $line = <$in>) {
	chomp $line;
	if ($line =~ /^# args=/) {
	    my ($type) = ($line =~ /\/(\S+).index\z/);
	    $dom = basename($type);
	    $dom =~ s/${name}_//;
	    $dom =~ s/_pdom//;
	    $all_pdoms{$dom} = 1;
	}
	next if $line =~ /^# \d+/;
	if ($line =~ /^(\d+):/) {
	    $clusnum = $1;
	}
	elsif ($line =~ /^\s+(\S+)/) {
	    my $element = $1;
	    $element =~ s/_\d+-\d+$//;
	    push @{$cls{$dom}{$clusnum}}, $element;
	}
    }
    close $in;

    my (%elem_sorted, %multi_cluster_elem);
    for my $pdom (keys %cls) {
	for my $clsnum (keys %{$cls{$pdom}}) {
	    for my $elem (@{$cls{$pdom}{$clsnum}}) {
		push @{$elem_sorted{$elem}}, { $pdom => $clsnum };
	    }
	}
    }

    my %dom_orgs;
    for my $element (keys %elem_sorted) {
	my $string;
	my %pdomh;
	@pdomh{keys %$_} = values %$_ for @{$elem_sorted{$element}};
	for my $pdom (nsort keys %cls) {
	    if (exists $pdomh{$pdom}) {
		$string .= length($string) ? "|$pdomh{$pdom}" : $pdomh{$pdom};
	    }
	    else {
		$string .= length($string) ? "|N" : "N";
	    }
	}
	push @{$dom_orgs{$string}}, $element;
	undef $string;
    }

    my $idx = 0;
    my %fastas;
    for my $str (reverse sort { @{$dom_orgs{$a}} <=> @{$dom_orgs{$b}} } keys %dom_orgs) {
	my $famfile = $sf."_family$idx".".fasta";
	my $outfile = File::Spec->catfile($cpath, $famfile);
	open my $out, '>>', $outfile;
	for my $elem (@{$dom_orgs{$str}}) {
	    if (exists $seqstore->{$elem}) {
		say $out join "\n", ">$sfname"."_family$idx"."_$elem", $seqstore->{$elem};
		delete $seqstore->{$elem};
	    }
	    else {
		die "\nERROR: $elem not found in store. Exiting.";
	    }
	}
	close $out;
	$idx++;
	$fastas{$outfile} = 1;
    }

    #if (%$seqstore) {
	my $famxfile = $sf."_singleton_families.fasta";
	my $xoutfile = File::Spec->catfile($cpath, $famxfile);
	open my $outx, '>', $xoutfile;
	for my $k (keys %$seqstore) {
	    my $seq = $seqstore->{$k};
	    $seq =~ s/.{60}\K/\n/g;
	    say $outx join "\n", ">$sfname"."_singleton_family_$k", $seq;
	}
	close $outx;
	$fastas{$xoutfile} = 1;
    #}
    #else { say "Debug: no keys left in seqstore"; }

    return \%fastas;
}

sub combine_families {
    my ($self) = shift;
    my ($outfiles) = @_;
    my $genome = $self->genome;
    my $outdir = $self->outdir;
    
    my ($name, $path, $suffix) = fileparse($genome, qr/\.[^.]*/);
    my $outfile = File::Spec->catfile($outdir, $name."_combined_LTR_families.fasta");
    open my $out, '>', $outfile;

    for my $file (nsort keys %$outfiles) {
	my $seqio = Bio::SeqIO->new( -file => $file, -format => 'fasta' );
	while (my $seqobj = $seqio->next_seq) {
	    my $id  = $seqobj->id;
	    my $seq = $seqobj->seq;
	    $seq =~ s/.{60}\K/\n/g;
	    say $out join "\n", ">$id", $seq;
	}
    }
    close $outfile;
}

sub _store_seq {
    my $self = shift;
    my ($file) = @_;

    my %hash;
    my $seqio = Bio::SeqIO->new( -file => $file, -format => 'fasta' );
    while (my $seqobj = $seqio->next_seq) {
	my $id  = $seqobj->id;
	$id =~ s/_\d+-\d+$//;
	my $seq = $seqobj->seq;
	$hash{$id} = $seq;
    }

    return \%hash;
}

sub _remove_singletons {
    my $self = shift;
    my ($args) = @_;

    my @singles;
    my ($index, $seqct) = (0, 0);
    for my $type (keys %$args) {
	delete $args->{$type} if ! @{$args->{$type}{seqs}};
	for my $db (@{$args->{$type}{seqs}}) {
	    my $seqio = Bio::SeqIO->new( -file => $db, -format => 'fasta' );
	    while (my $seqobj = $seqio->next_seq) { $seqct++ if defined $seqobj->seq; }
	    if ($seqct < 2) {
		push @singles, $index;
		unlink $db;
	    }
	    $index++;
	    $seqct = 0;
	}

	if (@{$args->{$type}{seqs}}) {
	    if (@singles > 1) {
		for (@singles) {
		    splice @{$args->{$type}{seqs}}, $_, 1;
		    @singles = map { $_ - 1 } @singles; # array length is changing after splice so we need to adjust offsets
		}
	    }
	    else {
		splice @{$args->{$type}{seqs}}, $_, 1 for @singles;
	    }
	}
	else {
	    delete $args->{$type};
	}
	$index = 0;
	@singles = ();
    }
}

=head1 AUTHOR

S. Evan Staton, C<< <statonse at gmail.com> >>

=head1 BUGS

Please report any bugs or feature requests through the project site at 
L<https://github.com/sestaton/tephra/issues>. I will be notified,
and there will be a record of the issue. Alternatively, I can also be 
reached at the email address listed above to resolve any questions.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Tephra::Classify::LTRFams


=head1 LICENSE AND COPYRIGHT

Copyright (C) 2015- S. Evan Staton

This program is distributed under the MIT (X11) License, which should be distributed with the package. 
If not, it can be found here: L<http://www.opensource.org/licenses/mit-license.php>

=cut 
	
__PACKAGE__->meta->make_immutable;

1;
